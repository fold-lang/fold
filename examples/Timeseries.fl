val device_series_to_json series = {
  let series =
    Device_series.mapi (fn {
        Device_series_key.metric_name = metric_name,
        ~device_id
      } values_by_time -> {
        let values =
          Ptime_map.to_seq values_by_time
          |> Seq.map (fn (_, v) -> Json.float v);
        Json.obj [
          ("metric", Json.string metric_name),
          ("device_id", Vendor_device_id.to_json device_id),
          ("values", Json.seq values)
        ];
      })
      series;
  Json.seq (Device_series.to_seq series
    |> Seq.map snd);
};

val generate_time_series_map ~start_time ~end_time ~resolution default = {
  let end_time_int = int_of_float (Ptime.to_float_s end_time);
  let rec loop time acc =
    if time >= end_time_int then
      acc
    else {
      let ptime =
        Ptime.of_float_s (float time)
        |> Option.get;
      let acc' = Ptime_map.add ptime default acc;
      loop (time + resolution) acc';
    };
  let rounded_start_time = {
    let ts = int_of_float (Ptime.to_float_s start_time);
    ts / resolution * resolution;
  };
  loop rounded_start_time Ptime_map.empty;
};

