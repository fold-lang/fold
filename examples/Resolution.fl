type t = {
  | Milliseconds
  | Second
  | Minute
  | Hour
  | Day
  | Week
  | Month
  | Quarter
  | Year
  | Decade
  | Century
  | Millennium
  | Seconds int
  | Minutes int
  | Hours int
  }

type person = {
  name : string,
  age : int
}

val re = Re.Posix.compile_pat "^([0-9]+)([a-z]+)$"

val parse_s_m_h str ->
  let regex_str_list = List.map Re.Group.all (Re.all re str) in
  match regex_str_list {
  | [ { _, number, "s" | "seconds" } ] -> Seconds (int_of_string number)
  | [ { _, number, "m" | "minutes" } ] -> Minutes (int_of_string number)
  | [ { _, number, "h" | "hours" } ] -> Seconds (int_of_string number)
  | [ { _, _number, unit } ] ->
    Fmt.failwith "incorrect resolution unit: %s" unit
  | _ -> Fmt.failwith "invalid resolution: %s" str
  }

val parse_constant {
  | "milliseconds" -> Milliseconds
  | "second" -> Second
  | "minute" -> Minute
  | "hour" -> Hour
  | "day" -> Day
  | "week" -> Week
  | "month" -> Month
  | "quarter" -> Quarter
  | "year" -> Year
  | "decade" -> Decade
  | "century" -> Century
  | "millennium" -> Millennium
  | _ -> invalid_arg str
  }

val of_string {
  | "" -> invalid_arg "empty resolution"
  | _ ->
    try (parse_constant str) {
      Invalid_argument _ -> parse_s_m_h str
    }
  }

val to_string {
  | Milliseconds -> "milliseconds"
  | Second -> "second"
  | Minute -> "minute"
  | Hour -> "hour"
  | Day -> "day"
  | Week -> "week"
  | Month -> "month"
  | Quarter -> "quarter"
  | Year -> "year"
  | Decade -> "decade"
  | Century -> "century"
  | Millennium -> "millennium"
  | Seconds n -> string_of_int n ^ "seconds"
  | Minutes n -> string_of_int n ^ "minutes"
  | Hours n -> string_of_int n ^ "hours"
  }

val is_constant {
  | Milliseconds
  | Second
  | Minute
  | Hour
  | Day
  | Week
  | Month
  | Quarter
  | Year
  | Decade
  | Century
  | Millennium -> True
  | Seconds _ | Minutes _ | Hours _ -> False
  }
