// https://github.com/ocaml/ocaml/blob/trunk/stdlib/effect.ml

//type t 'a = ..;
//external perform : 'a t -> 'a = "%perform"

//type exn += Unhandled: 'a t -> exn
//exception Continuation_already_resumed

do {
  let printer = {
    Unhandled x -> {
      let msg = Printf.sprintf "Stdlib.Effect.Unhandled(%s)"
          (Printexc.string_of_extension_constructor @@ Obj.repr x);
      Some msg
    },
    _ -> None
  };
  Printexc.register_printer printer
};

// Register the exceptions so that the runtime can access it
//type _ t += Should_not_see_this__ : unit t
_ = Callback.register_exception "Effect.Unhandled"
          (Unhandled Should_not_see_this__);
_ = Callback.register_exception "Effect.Continuation_already_resumed"
          Continuation_already_resumed;

//type ('a, 'b) stack

//external resume : ('a, 'b) stack -> ('c -> 'a) -> 'c -> 'b = "%resume"
//external runstack : ('a, 'b) stack -> ('c -> 'a) -> 'c -> 'b = "%runstack"

mod Deep = {
//  type ('a,'b) continuation
  type last_fiber;

//  external take_cont_noexc : ('a, 'b) continuation -> ('a, 'b) stack =
//    "caml_continuation_use_noexc" [@@noalloc]
//  external alloc_stack :
//    ('a -> 'b) ->
//    (exn -> 'b) ->
//    ('c t -> ('c, 'b) continuation -> last_fiber -> 'b) ->
//    ('a, 'b) stack = "caml_alloc_stack"

  continue = k v -> resume (take_cont_noexc k) (x -> x) v;

  discontinue = k e -> resume (take_cont_noexc k) (e -> raise e) e;

  discontinue_with_backtrace = k e bt ->
    resume (take_cont_noexc k) (e -> Printexc.raise_with_backtrace e bt) e;

//  type ('a,'b) handler =
//    { retc: 'a -> 'b;
//      exnc: exn -> 'b;
//      effc: 'c.'c t -> (('c,'b) continuation -> 'b) option }
//
//  external reperform :
//    'a t -> ('a, 'b) continuation -> last_fiber -> 'b = "%reperform"

  match_with = comp arg handler -> {
    let effc = eff k last_fiber ->
      match (handler.effc eff) {
        Some f -> f k,
        None -> reperform eff k last_fiber
      };
    let s = alloc_stack handler.retc handler.exnc effc;
    runstack s comp arg
  };

//  type 'a effect_handler =
//    { effc: 'b. 'b t -> (('b,'a) continuation -> 'a) option }

  try_with = comp arg handler -> {
    let effc' = eff k last_fiber ->
      match (handler.effc eff) {
        Some f -> f k,
        None -> reperform eff k last_fiber
      };
    let s = alloc_stack (x -> x) (e -> raise e) effc';
    runstack s comp arg
  };

//  external get_callstack :
//    ('a,'b) continuation -> int -> Printexc.raw_backtrace =
//    "caml_get_continuation_callstack"
};

mod Shallow = {
//  type ('a,'b) continuation
  type last_fiber;

//  external alloc_stack :
//    ('a -> 'b) ->
//    (exn -> 'b) ->
//    ('c t -> ('c, 'b) continuation -> last_fiber -> 'b) ->
//    ('a, 'b) stack = "caml_alloc_stack"

//  let fiber : type a b. (a -> b) -> (a, b) continuation = fun f ->
//    let module M = struct type _ t += Initial_setup__ : a t end in
//    let exception E of (a,b) continuation in
//    let f' () = f (perform M.Initial_setup__) in
//    let error _ = failwith "impossible" in
//    let effc eff k _last_fiber =
//      match eff with
//      | M.Initial_setup__ -> raise_notrace (E k)
//      | _ -> error ()
//    in
//    let s = alloc_stack error error effc in
//    match runstack s f' () with
//    | exception E k -> k
//    | _ -> error ()

//  type ('a,'b) handler =
//    { retc: 'a -> 'b;
//      exnc: exn -> 'b;
//      effc: 'c.'c t -> (('c,'a) continuation -> 'b) option }

//  external update_handler :
//    ('a,'b) continuation ->
//    ('b -> 'c) ->
//    (exn -> 'c) ->
//    ('d t -> ('d,'b) continuation -> last_fiber -> 'c) ->
//    ('a,'c) stack = "caml_continuation_use_and_update_handler_noexc" [@@noalloc]

//  external reperform :
//    'a t -> ('a, 'b) continuation -> last_fiber -> 'c = "%reperform"

  continue_gen = k resume_fun v handler -> {
    let effc = eff k last_fiber ->
      match (handler.effc eff) {
        Some f -> f k,
        None -> reperform eff k last_fiber
      };
    let stack = update_handler k handler.retc handler.exnc effc;
    resume stack resume_fun v
  };

  continue_with = k v handler ->
    continue_gen k (x -> x) v handler;

  discontinue_with = k v handler ->
    continue_gen k (e -> raise e) v handler;

  discontinue_with_backtrace = k v bt handler ->
    continue_gen k (e -> Printexc.raise_with_backtrace e bt) v handler;

//  external get_callstack :
//    ('a,'b) continuation -> int -> Printexc.raw_backtrace =
//    "caml_get_continuation_callstack"
};

