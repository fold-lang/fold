// @fold { version = "1.0" };

do
  a;
  f a b;
  f a b c d e;
  42;
  ()

// Values
(val x 1)

(val
  [x 1
   y 2])

// rec {
//   x = 1, y = 2
// };

val a = (42 + 10 - 2) / 2
do print_newline ()
do print_endline (string_of_int (a + b))

// Constructors
val x = None
val x = Some 1
val x = Some [1, 2, 3]
val x = Two 1 2
val x = Two 1 2 |> f

// Polymorphic variants
val x = #A
val x = #A #B
val x = #A 42
val x = #A (2 + a)
val x = #A a 42
val x = #A (b, 43)
val x = #A |> f
val x = f #A #B
val x = f #A #B <| #C

// Field and mod access.
do {
  // value access
  M.x;
  M.x1.x2;
  M1.M2.x;
  M1.M2.x1.x2;
  M1.M2.M3.x;
  M1.M2.M3.x1.x2.x3;

  // constructor access
  M.C;
  M1.M2.C;
  M1.M2.M3.C;

  // field access
  r.fld;
  (foo 42).fld;
  (M1.M2.r).fld;
  M1.M2.r.fld;
  M.r.fld;
  M.x1.x2.x3.x4;

  // qualified field access
  x1.(M.x2);
  x1.(M1.M2.x2);
  x1.x2.(M1.x3);

  // constructor expressions (semantically incorrect)
  // NOTE: might be incorrectly printed by OCaml's Pprintast.
  (C).fld;
  (M.C).fld;
  (M1.M2.C).fld;
  
  // qualified function apply
  M.f v;
  M1.M2.f v;
  M1.M2.M3.f v;

  // qualified constructor apply
  M.C v;
  M1.M2.C v;
  M1.M2.M3.C v;

  // qualified function arg
  f M.v;
  f M1.M2.v;
  f M1.M2.M3.v;
  
  // field function arg
  f r.fld;
  f r.(M.fld);
  f r.(M1.M2.fld);
  f M1.r.fld;

  // qualified constructor arg
  C M.v;
  C M1.M2.v;
  C M1.M2.M3.v;

  // qualified apply misc
  M.f M.v;
  M1.f r.(M2.fld);
  M1.M2.f M3.M4.v;
  M1.M2.f r.(M3.M4.M5.fld);
  M.r.fld v;

  // TODO local open
  // M.(a + b)
  // M.(x1.x2)
  // M.(x1).x2
  // M1.(x1).(M2.x2)

  // TODO type ident
  // (Set.Make M).t;

  // Deep.
  M.M.M.M.M;
  x.x.x.x.x;

  // Edge cases
  x1.x2.(M1.M2.x4).(M3.x5);
  M1.M2.x1.x2.(M3.M4.x4).(M5.x6);
  M1.x1.x2.(x3);
  M1.x1.x2.x3.(x4);
  M1.x1.(x2).x3.(x4).(M2.M3.x5);
  x1.(x2).(x3).(x4);
  
  // errors
  // r.M;
  // r.M.x;
  // x1.(M2.x2.x3); // expected ident
};

// Unit pattern, implicit let unit
() = ();
() = {
  let a = 1;
  a
};
() = {
  let a = 1
};
() = {
  let a = 1, b = 2
};
() = {
  let a = 1;
  let b = 2;
};

do { let a = 1 };

// Scopes
// { }; // array? unit?
// { ; }; // empty block? unit?
{ a };
{ a; };
{ a; b };
{ a; b; };
{ a; b; c; };
{ a; b; c };
{
  f ();
  let a = 1;
  a
};

// List expressions
x = [];
x = [1];
x = [1, 2];
x = [1, 2, 3];
x = [0 & xs];
x = [1, 2 & xs];

// List patterns
[] = x;
[1] = x;
[1, 2] = x;
[1, 2 & xs] = x;
[[], [1, 2] & xs] = x;

// Arrays
// x = {a};
// x = {a, b, c};

// create record
record_create_triple = { a = "A", b = 1, c = 2 };
record_create_single_pun = { ~a };
record_create_single = { a = 1 };
record_create_double_mixed_1 = { ~a, b = 1 };
record_create_double_mixed_2 = { a = 1, ~b };
record_create_triple = { ~a, ~b, ~c };
record_create_functions = {
  a = 1,
  f = x -> x + 1,
  g = x y -> x - y
};

// update record
record_update_double = { r & a = 23, b = 1 };
record_update_double_mixed_1 = { r & a = 23, ~b };
record_update_double_mixed_2 = { r & ~a, b = 1 };
record_update_single_pun = { r & ~a };
record_update_double_pun = { r & ~a, ~b };
record_update_single = { r & a = 1 };

// Lambda
f = a -> a + 1;
fn sum a b -> a + b

// This matches on an singleton array
// let f = fn {a} -> a + 1;

// This matches on a record
//let f = fn {~a} -> a + 1;

// This wraps a single case.
f = { a -> a + 1 };
//let f = fn {
//  | a -> a + 1
//  };
f = { a -> a + 1 } + 1;

// Lambda with cases
x = { a -> 1, b -> 2 };

// Lambda argument
x = xs |> List.map { x -> x + 1 };

// if else
x = if a b c;
x = if a { x; b } { c };
x = if a { x; b; } { y; c; };
x = { if a { b } { c }; x; };
x = if a { b } { c } + 1;
x = if a b c + 1;
// err
//let x = if a { b } else c + 1;

// if
x = if a { b };
x = if a { print_newline (); b; };
x = if a { b + 1 };
x = if a { b } + 1;
x = if a b + 1;

// Syntax errors
//let x = if a; x then b else c;
//let x = if a then b; x else c;
// let + 1;

// match
x = match a {
  1 -> 0,
  2 -> b
};
x = match a { 1 -> 0 };
x = match (a + b) {
  1 -> 0,
  2 -> b
};
x = match a { 1 -> b | 2 -> c } + 100;
x =
    match a {
    | 1 ->
        print_endline "1";
        a
    | 2 -> b
    };

x =
  match a {
  | 1 -> 0
  | x if x > 0 -> b
  | _ -> 1
  };

// "lambda match"
x =
  a
  |> {
    1 -> 0,
    2 -> b
  }
  |> String.upper
  |> {
  | 1 -> 0
  | 2 -> b
  }


// match refute?
// x = match a { _ -> . };

// try
x = try (f ()) { a -> prerr_endline msg };
x = try (f ()) {
  a -> prerr_endline msg,
  b -> bar
};

// Module bindings
mod M1 = X
mod M2 = {}
mod M3 = {
  a = 1;
  b = 2;
}

// Module bindings with constraint
mod M4 : {} = {};
mod M5 : { x : int } = { x = 42 };
mod M6 : { x : int; y : int; } = { x = 42; y = 2; };

// Module type
sig S1 = {
  a : int;
  b : bool;
}

// open
open M
let x =
  let a = 1 in
  open M in
  a

let x =
  open M in
  let
    a = 1,
    b = 2
  in
    a

// application labels
{
  f ~a:1;
  f ~a;
  f ~a?:b;
  f ~a?;
  f ~a:1 ~a ~a?:b ~a?;
  f x ~a:1;
  f ~a:1 x;
  f w ~a:1 x ~a y ~a?:b z ~a?;
  f ~a:(2 + 3);
  f ~a?:None;

  (f (~ a 1))
  (f :a)
  (f :[?a?:b)
  f ~a?;
  f ~a:1 ~a ~a?:b ~a?;
  f x ~a:1;
  f ~a:1 x;
  f w ~a:1 x ~a y ~a?:b z ~a?;
  f ~a:(2 + 3);
  f ~a?:None;

  // f w (a=1) x (=a) y (a=?b) z (=a?);
  // f w, a=1, x, =a, y, a=?b, z, =a?;
  // f w, a:1, x, :a, y, a:?b, z, :?a;
  // f[w, a=1, x, =a, y, a=?b, z, =?a];

  // f ~(a)
  // f ~(a : int)
  // f ~a:(b:int)

  // errors
  // f ~M;
  // f ~2;
  // f ~(a);
};

// type record
//type person = { name : string, age : int, profession : option string };


//mod Person = {
//  print = p -> print_endline (p.name ^ " " ^ string_of_int p.age)
//};
//
//p = { name = "Anonymous"; age = 0; profession = None };
//
//f ~a ?(opt = 0) ?use ~name x = {
//  ignore (a, opt, use, name, x);
//  opt
//};
//
//x = {
//  let* x = 2, y = (3, 'a')[
//  let age = 30 - fst y;
//  let person = { p & name = "Xavier"; age };
//  Person.print person;
//  let result = {
//    let a, opt, foo = (1, None, Some (if age > 30 then 0 else 10));
//    f ~a ?opt ?use:foo ~name:"hello" x
//  };
//  let* map : ('a -> 'b) -> 'a list -> 'b list =
//    f l ->
//      match l {
//        [] -> [],
//        [x & xs] -> [f x & map f xs]
//      };
//  x + result - { let z = p.age; z * 2 }
//}



// PPX

// Extension
//x = extension! (env "HOME");

//do {
  // [%env "HOME"]
  //env! "HOME";

  // [%pp: int list]
  //pp! "HOME";

  // [%view? (Some _ as x) :: []]
  //pp! "HOME";

  // [%mody let x = 1;; let y = 2]
  //pp! "HOME";

  // [%sigy: val x : int;; val y : bool]
  //pp! "HOME"
//};


// while
do {
  while e1 e2;
  while (x > 1) {
    print "hello";
    f ();
  };
};

// for
do {
  for (i = e1 to e2) e3;
  for (i = e1 downto e2) e3;
  for (i = e1 to e2) {
    print "hello";
    f ();
  };
};

// constraint
// if tight prec cannot be used for :, consider forcing (_ : _).
do {
  x : t;
  2 + (x : int) * 2;
  // 2 + f x y : int * 2;
  f (x : int) y;
  f (xs : list int);
};

// value constraint
v_constraint_1 : int = 42;
v_constraint_2 : list (string, int) = [("a", 2), ("b", 3)];
// v_constraint_3 : type a . a = a;
// v_constraint_4 : 'a . 'a  = a;

// type
type t;
type nonrec t;
type t = int;
type t = list int;
type t = list (list int);
type nonrec t = int;

// type tuple
type t = (int, bool);

// type variant
type t = A;
type t = A int;
type t = A int string;
type t = { A };
type t = { A int };
type t = { A int string };
type t = { A (int, string) };

type t = { A | B | C };
type t = { A | B int bool };

type t = u == A;
type t = u == { A | B int };

// type record
type t = { a : int, b : list bool };
type t = u == { a : int, b : list bool };
type t = { a : mutable int, b : mutable (list bool) };
type t = ..;

// type private
// @private
// type t = int;

// @(derive debug)
// type t = int;

// @[
//   derive debug,
//   abstract,
//   private,
//   constraint { 'a = float, 'b = (int, 'a) }
// ]
// type t = int;

// @(derive debug)
// @abstract
// @private
// @(constraint { 'a = float, 'b = (int, 'a) })
// type t = int;

// type constraints
// type t = int constraint t1 = t2;
// @constraint (a = int list, b = _ option)
// type t = X a b,
//   constraint a = int list,
//   constraint b = _ option;
// type t = {
// a : int
// } constraint t1 = t2
// constraint t3 = t4;

// (type t {
//   a : int
// } :constraint (= t1 t2)
// :constraint (= t1 t2))

// @(constraint 'a = list (float, 'b))
// type t 'a = {
//   x : int,
//   y : 'a
// };

// @private
// @constraint (a = int list)
// @(constraint (b = _ option)
// type t = { a : int };

// @(deriving json)
// type t = { a : int };

// @deriving json 42
// type t = { a : int };


// Extras

// Macro calls

x = mc1! (2);
x = mc2! (2) + 1;
x = mc3! { <div> "hello" </div> };
//x = mc1! a b;
//x = mc1! a b + 1;

// field acessors
// do {
//   .x;
//   .x1.x2;
//   map (.x1) xs;
//   map (.x1.x2) xs;
// };


// use
// use List {map; fold_left as fold; type json; mod Map};
// use List.fold_left;
// use String.Map as Smap;
// use String.Map as Smap { ... };

// if cases
x = if {
  a > 1 -> "yes",
  a == 0 -> "maybe",
  else -> "no"
};

// lambda with holes
// List.map (f _ x)
