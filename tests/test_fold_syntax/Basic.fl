a;
f a b;
42;
();

let a = (42 + 10 - 2) / 2;
let b = calc! (1000 + 1);
let c = xml! <p> "hello" </p> + 1;
print_newline ();
print_endline (string_of_int (a + b));


// Constructors
let x = None;
let x = Some 1;
let x = Some [1, 2, 3];
let x = Two 1 2;
// BUG #1
// let x = Two 1 2 |> f;


// Unit pattern, implicit let unit
let () = ();
let () = {
  let a = 1;
  a
};
let () = {
  let a = 1
};
let () = {
  let a = 1;
  let b = 2
};

// Scopes
// { }; // array? unit?
{ print_endline "hello" };
{
  print_endline "hello";
  print_endline "world"
};


// Lists
let xs = [];
let xs = [1];
let xs = [1, 2];
let xs = [1, 2, 3];
let xs = [0, ..xs];

// Lambda
let f = fn a -> a + 1;
let sum = fn a b -> a + b;

// This matches on an singleton array
// let f = fn {a} -> a + 1;

// This matches on a record
//let f = fn {~a} -> a + 1;

// This wraps a single case.
let f = fn { a -> a + 1 };
let f = fn {
  | a -> a + 1
  };

// Lambda with cases
let x = fn { a -> 1 | b -> 2 };

// if_then_else
let x = if a then b else c;
let x = if a then { x; b } else c;
let x = if a then { x; b } else { y; c };
let x = (if a then b else c; x);
// Syntax errors
//let x = if a; x then b else c;
///let x = if a then b; x else c;

// match
let x =
  match a {
    1 -> 0
  | 2 -> b
  };
let x =
  match a {
  | 1 -> 0
  | 2 -> b
  };
let x =
  match (a + b) {
  | 1 -> 0
  | 2 -> b
  };

// Module bindings
module M1 = X;
module M2 = {};
module M3 = {
  let a = 1;
  let b = 2
};

// open
open M;
let x = {
  let a = 1;
  open M;
  a
};

// Code quoting
let x = `a`;
let x = `1`;
let x = `"abc"`;
let x = `f x`;
let x = `1 + 2`;
let x = `[1, 2, 3]`;
let x = `((42))`;
let x = `let x = 1`;
let x = `let a = 42; a + 1`;

// Code antiquoting
let int_code = `42`;
let x = `1000 + $int_code`;
let x = `1000 + $(`42`)`
