// structure_item

// value
// let P1 = E1 and ... and Pn = EN
// let rec P1 = E1 and ... and Pn = EN
val P1 = E1 and ... and Pn = EN
val rec P1 = E1 and ... and Pn = EN

// primitive
// val x : T
// external x : T = "s1" ... "sn"
val x : T
external x : T = "s1" ... "sn"

// type
type t1 = ... and ... and tn = ...
type t1 = ... and ... and tn = ...

// typext
type t1 += ...

// exception
// exception C of T
// exception C = M.X
exception C T
exception C = M.X

// module
// module X = ME
module X = ME

// recmodule
// module rec X1 = ME1 and ... and Xn = MEn
module rec X1 = ME1 and ... and Xn = MEn

// modtype
// module type S = MT
module type S = MT

// open
// open X
open X

// class
// class c1 = ... and ... and cn = ...
class c1 = ... and ... and cn = ...

// class_type
// class type ct1 = ... and ... and ctn = ...
class type ct1 = ... and ... and ctn = ...

// include
// include ME
include ME

// attribute
// [@@@id]
@id

// extension
%id




core_type 
any _
var 'a
arrow ~l:T -> T
tuple T1 * ... * Tn
constr  
object  
class 
alias 
variant 
poly  
package 
extension 
row_field 
tag 
inherit 
object  
tag 
inherit 
pattern 
any _
var x
alias P as 'a
const 
interval  a'..'z'
tuple (P1, ..., Pn)
constr  "C
C P
C P1 ... Pn
C (type a b) P"
variant "`A
`A P"
record  "{ l1=P1; ...; ln=Pn }
{ l1=P1; ...; ln=Pn; _ }"
array [| P1; ...; Pn |]
or  P1 | P2
constraint  (P : T)
type  #tconst
lazy  lazy P
unpack  "(module P)
(module _)"
exception exception P
extension [%id]
open  M.(P)
exp 
ident 
const 
let "let P1 = E1 and ... and Pn = EN in E
let rec P1 = E1 and ... and Pn = EN in E"
function  function P1 -> E2 | ... | Pn -> En
fun fun P -> E
apply E0 ~l1:E1 ... ~ln:En
match match E0 with P1 -> E1 | ... | Pn -> En
try try E0 with P1 -> E1 | ... | Pn -> En
tuple (E1, ..., En)
constr  "C
C E
C (E1, ..., En)"
variant "`A
`A E"
record  "{ l1=P1; ...; ln=Pn }
{ E0 with l1=P1; ...; ln=Pn }"
field E.l
setfield  E1.l <- E2
array [| E1; ...; En |]
ifthenelse  
sequence  E1; E2
while while E1 do E2 done
for "for i = E1 to E2 do E3 done
for i = E1 downto E2 do E3 done"
constraint  (E : T)
coerce  "(E :> T)
(E : T0 :> T)"
send  E#m
new new M.c
setinstvar  x <- 2
override  {< x1 = E1; ...; xn = E >}
letmodule let module M = ME in E
letexception  let exception C in E
assert  assert E
lazy  lazy E
poly  
object  object ... end
newtype fun (type t) -> E
pack  (module ME)
open  "M.(E)
let open M in E"
letop "let* P = E0 in E1
let* P0 = E00 and* P1 = E01 in E1"
extension [%id]
unreachable .
type_declaration  
  type t
  type t = T0
  type t = C of T | …
  type t = T0 = C of T | …
  type t = { l : T; … }
  type t = ..
  
  type += …
constructor_declaration 
  C of T1 * … * Tn
  C : T0
  C : T0 * … * Tn -> T0
  C of { … }
  C : { … } -> T0
class_signature 
  object (self) … end
  object … end
class_type_field  
  inherit CT
  val x : T
  method x : T
  constraint T1 = T2
class_infos 
  class c = …
  class ['a1, …, 'an] c = …
  class virtual c = …
  
class_field inherit CE
  inherit CE as x
  inherit! CE
  inherit! CE as x
  initializer E
  
module_type S
  sig end
  functor (M : MT1) -> MT2
  MT with …
  module type of ME
  (module M)
  
  
  val x : T
  external x : T = "…"
  type t1 = … and t2 = …
  type tq := … and t2 := …
  type += …
  exception C of T
  module X = M
  module X : MY
  module X := M
  module rec X1 : MT1 and Xn : MTn
  module type S = MT
  module type S := MT
  open X
  include MT
  class c1 : … and …
  class type ct1 = … and …
  [@@@id]
  [%%id]