
open Pure
open Base
open Lex

module M = Map.Make(Token)


type error =
  | Msg of string
  | Empty
  | Unexpected_end   of { expected : token }
  | Unexpected_token of { expected : token; actual : token }


let error_to_string e =
  match e with
  | Empty -> "empty"

  | Unexpected_end { expected } ->
    "expected `%s` but input terminated" % Token.show expected

  | Unexpected_token { expected; actual } ->
    "expected `%s` but got `%s`" % (Token.show expected, Token.show actual)

  | Msg msg ->
    msg

type ('a, 'state) parser = 'state -> ('a * 'state, error) result

type 'a led = ('a -> ('a, 'a state) parser) * int

and 'a nud = ('a, 'a state) parser

and 'a state = {
  lexer   : Lexer.t;
  grammar : 'a grammar;
  token   : Token.t;
}

and 'a scope = {
  nud : 'a nud M.t;
  led : 'a led M.t;
}

and 'a grammar = {
  data : 'a scope list;
  atom : Token.t -> 'a nud;
  form : Token.t -> 'a led;
}

type 'a rule =
  | NUD of 'a nud
  | LED of 'a led


let (>>=) p f = fun s ->
  match p s with
  | Ok (x, s') -> (f x) s'
  | Error msg  -> Error msg

let return x  = fun s -> Ok (x, s)


let get       = fun s -> Ok (s, s)
let put s     = fun _ -> Ok ((), s)

let modify f =
  get >>= fun s -> put (f s)

let zero      = fun s -> Ok ((), s)

let empty     = fun s -> Error Empty

let error msg = fun _ -> Error msg

let (<|>) p1 p2 = fun state ->
  match p1 state with
  | Ok value -> Ok value
  | Error _  -> p2 state


let combine p1 p2 =
  p1 >>= fun x ->
  p2 >>= fun y -> return (x, y)


let with_default default p =
  p <|> return default


let optional p =
  with_default () p


let rec many p =
  (p >>= fun x -> many p >>= fun xs -> return (x :: xs))
  |> with_default []


let rec some p =
  combine p (many p) >>= fun (x, xs) -> return (x :: xs)


let sequence mas =
  List.fold_right
    (fun ma ms ->
       ma >>= fun a ->
       ms >>= fun s ->
       return (a :: s))
    mas
    (return [])


module Grammar = struct
  type 'a t = 'a grammar


  let dump self =
    let string_of_nud _ = "<nud>" in
    let string_of_led (_, p) = "<led %d>" % p in
    List.iteri (fun i { nud; led } ->
        print ("nud [%d]:" % i);
        M.iter (fun k v -> print ("%s => %s" % (Token.to_string k, string_of_nud v))) nud;
        print ("led [%d]:" % i);
        M.iter (fun k v -> print ("%s => %s" % (Token.to_string k, string_of_led v))) led;
        print "")
      self.data


  let invalid_led ?(lbp = 0) token =
    let parse left =
      let msg = "%s cannot be used in infix position" % Token.to_string token in
      error (Msg msg) in
    (parse, lbp)


  let invalid_nud token =
    let msg = if token = Lex.eof
      then "unexpected end of input"
      else "%s cannot be used in prefix position" % Token.to_string token in
    error (Msg msg)


  let empty = {
    data = [];
    atom = invalid_nud;
    form = invalid_led;
  }


  let empty_scope = {
    nud = M.empty;
    led = M.empty;
  }


  let add_led token rule self =
    let first, rest =
      match self.data with
      | [] -> empty_scope, []
      | first::rest -> first, rest in
    let first' = { first with led  = M.add token rule first.led } in
    { self with data = first'::rest }


  let add_nud token rule self =
    let first, rest =
      match self.data with
      | [] -> empty_scope, []
      | first::rest -> first, rest in
    let first' = { first with nud  = M.add token rule first.nud } in
    { self with data = first'::rest }


  let add (token, denotation) self =
    match denotation with
    | `NUD rule -> add_nud token rule self
    | `LED rule -> add_led token rule self


  let scope_of_list rules =
    List.fold_left
      (fun scope -> function
         | (token, `NUD rule) -> { scope with nud = M.add token rule scope.nud }
         | (token, `LED rule) -> { scope with led = M.add token rule scope.led })
      empty_scope
      rules


  let get_nud token self =
    let rec loop data =
      match data with
      | s :: rest -> Option.(M.find token s.nud <|> lazy (loop rest))
      | [] -> None in
    loop self.data or lazy (self.atom token)


  let get_led token self =
    let rec loop data =
      match data with
      | s :: rest -> Option.(M.find token s.led <|> lazy (loop rest))
      | [] -> None in
    loop self.data or lazy (self.form token)


  let init ?(form = invalid_led ~lbp:90) ?(atom = invalid_nud) rules =
    let scope = scope_of_list rules in
    { data = [scope]; atom; form }
    |> add_nud Lex.eof (invalid_nud Lex.eof)
    |> add_led  Lex.eof (invalid_led Lex.eof)

end


let rec nud rbp =
  get >>= fun { grammar; token } ->
  let parse = Grammar.get_nud token grammar in
  parse >>= fun left ->
  led rbp left


and led rbp left =
  get >>= fun { grammar; token } ->
  let (parse, lbp) = Grammar.get_led token grammar in
  if lbp > rbp then
    parse left >>= led rbp
  else
    return left


let parse () = nud 0


let advance () =
  modify (fun s -> { s with token = Lexer.read s.lexer })


let expect expected =
  get >>= fun { token = actual } ->
  match () with
  | () when actual = expected -> return actual
  | () when actual = Lex.eof -> error (Unexpected_end { expected })
  | () -> error (Unexpected_token { expected; actual })


let consume tok =
  expect tok >>= fun _ -> advance ()


let run parser ~grammar lexer =
  let token = Lexer.read lexer in
  let state = { grammar; lexer; token } in
  match parser state with
  | Ok (expr, _) -> Ok expr
  | Error e -> Error e


let push_scope scope =
  modify begin fun state ->
    let data = scope :: state.grammar.data in
    let grammar = { state.grammar with data } in
    { state with grammar }
  end


let pop_scope () =
  modify begin fun state ->
    match state.grammar.data with
    | [] -> state
    | _ :: rest ->
      let grammar = { state.grammar with data = rest } in
      { state with grammar }
  end


let with_scope s p =
   push_scope s >>= fun () ->
   p >>= fun x ->
   pop_scope () >>= fun () ->
   return x


let singleton x =
  advance () >>= fun () ->
  return x


let delimiter str =
  let parse _ = error (Msg "unexpected delimiter") in
  (`Symbol str, `LED (parse, 0))


let infix precedence str f =
  let parse x =
    advance () >>= fun () ->
    nud precedence >>= fun y ->
    return (f x y) in
  (`Symbol str, `LED (parse, precedence))


let infixr precedence str f =
  let parse x =
    advance () >>= fun () ->
    nud (precedence - 1) >>= fun y ->
    return (f x y) in
  (`Symbol str, `LED (parse, precedence))


let prefix str f =
  let parse =
    advance () >>= fun () ->
    parse () >>= fun x ->
    return (f x) in
  (`Symbol str, `NUD parse)


let postfix precedence str f =
  let parse x =
    advance () >>= fun () ->
    return (f x) in
  (`Symbol str, `LED (parse, precedence))


let between s e f =
  let parse =
    advance () >>= fun () ->
    parse () >>= fun x ->
    consume (`Symbol e) >>= fun () ->
    return (f x) in
  (`Symbol s, `NUD parse)


